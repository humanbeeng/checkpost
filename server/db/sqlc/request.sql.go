// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: request.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createNewRequest = `-- name: CreateNewRequest :one
INSERT INTO
    request (
        user_id,
        endpoint_id,
        PATH,
        response_id,
        CONTENT,
        METHOD,
        UUID,
        source_ip,
        content_size,
        response_code,
        headers,
        query_params,
        expires_at
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13
    )
RETURNING
    id, uuid, user_id, endpoint_id, plan, path, response_id, content, method, source_ip, content_size, response_code, headers, query_params, created_at, expires_at, is_deleted
`

type CreateNewRequestParams struct {
	UserID       pgtype.Int8        `json:"user_id"`
	EndpointID   int64              `json:"endpoint_id"`
	Path         string             `json:"path"`
	ResponseID   pgtype.Int8        `json:"response_id"`
	Content      pgtype.Text        `json:"content"`
	Method       HttpMethod         `json:"method"`
	Uuid         string             `json:"uuid"`
	SourceIp     string             `json:"source_ip"`
	ContentSize  int32              `json:"content_size"`
	ResponseCode pgtype.Int4        `json:"response_code"`
	Headers      []byte             `json:"headers"`
	QueryParams  []byte             `json:"query_params"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateNewRequest(ctx context.Context, arg CreateNewRequestParams) (Request, error) {
	row := q.db.QueryRow(ctx, createNewRequest,
		arg.UserID,
		arg.EndpointID,
		arg.Path,
		arg.ResponseID,
		arg.Content,
		arg.Method,
		arg.Uuid,
		arg.SourceIp,
		arg.ContentSize,
		arg.ResponseCode,
		arg.Headers,
		arg.QueryParams,
		arg.ExpiresAt,
	)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.UserID,
		&i.EndpointID,
		&i.Plan,
		&i.Path,
		&i.ResponseID,
		&i.Content,
		&i.Method,
		&i.SourceIp,
		&i.ContentSize,
		&i.ResponseCode,
		&i.Headers,
		&i.QueryParams,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.IsDeleted,
	)
	return i, err
}

const deleteExpiredRequests = `-- name: DeleteExpiredRequests :exec
DELETE FROM request
WHERE
    expires_at < NOW()
`

func (q *Queries) DeleteExpiredRequests(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredRequests)
	return err
}

const getEndpointHistory = `-- name: GetEndpointHistory :many
SELECT
    request.id,
    request.uuid,
    request.user_id,
    request.plan,
    request.path,
    request.response_id,
    request.response_code,
    request.content,
    request.method,
    request.source_ip,
    request.content_size,
    request.headers,
    request.query_params,
    request.created_at,
    request.expires_at,
    endpoint.endpoint AS endpoint
FROM
    request
    LEFT JOIN endpoint ON request.endpoint_id = endpoint.id
WHERE
    endpoint.endpoint = $1
    AND request.is_deleted = FALSE
    AND request.expires_at > NOW()
LIMIT
    $2
OFFSET
    $3
`

type GetEndpointHistoryParams struct {
	Endpoint string `json:"endpoint"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

type GetEndpointHistoryRow struct {
	ID           int64              `json:"id"`
	Uuid         string             `json:"uuid"`
	UserID       pgtype.Int8        `json:"user_id"`
	Plan         Plan               `json:"plan"`
	Path         string             `json:"path"`
	ResponseID   pgtype.Int8        `json:"response_id"`
	ResponseCode pgtype.Int4        `json:"response_code"`
	Content      pgtype.Text        `json:"content"`
	Method       HttpMethod         `json:"method"`
	SourceIp     string             `json:"source_ip"`
	ContentSize  int32              `json:"content_size"`
	Headers      []byte             `json:"headers"`
	QueryParams  []byte             `json:"query_params"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
	Endpoint     pgtype.Text        `json:"endpoint"`
}

func (q *Queries) GetEndpointHistory(ctx context.Context, arg GetEndpointHistoryParams) ([]GetEndpointHistoryRow, error) {
	rows, err := q.db.Query(ctx, getEndpointHistory, arg.Endpoint, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEndpointHistoryRow{}
	for rows.Next() {
		var i GetEndpointHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.UserID,
			&i.Plan,
			&i.Path,
			&i.ResponseID,
			&i.ResponseCode,
			&i.Content,
			&i.Method,
			&i.SourceIp,
			&i.ContentSize,
			&i.Headers,
			&i.QueryParams,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Endpoint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEndpointRequestCount = `-- name: GetEndpointRequestCount :one
SELECT
    COUNT(*) AS total_count,
    COUNT(
        CASE
            WHEN response_code = 200 THEN 1
        END
    ) AS success_count,
    COUNT(
        CASE
            WHEN response_code != 200 THEN 1
        END
    ) AS failure_count
FROM
    request r
    LEFT JOIN endpoint e ON r.endpoint_id = e.id
WHERE
    endpoint = $1
    AND is_deleted = FALSE
    AND expires_at > NOW()
`

type GetEndpointRequestCountRow struct {
	TotalCount   int64 `json:"total_count"`
	SuccessCount int64 `json:"success_count"`
	FailureCount int64 `json:"failure_count"`
}

func (q *Queries) GetEndpointRequestCount(ctx context.Context, endpoint string) (GetEndpointRequestCountRow, error) {
	row := q.db.QueryRow(ctx, getEndpointRequestCount, endpoint)
	var i GetEndpointRequestCountRow
	err := row.Scan(&i.TotalCount, &i.SuccessCount, &i.FailureCount)
	return i, err
}

const getRequestById = `-- name: GetRequestById :one
SELECT
    id, uuid, user_id, endpoint_id, plan, path, response_id, content, method, source_ip, content_size, response_code, headers, query_params, created_at, expires_at, is_deleted
FROM
    request
WHERE
    id = $1
    AND is_deleted = FALSE
    AND expires_at > NOW()
LIMIT
    1
`

func (q *Queries) GetRequestById(ctx context.Context, id int64) (Request, error) {
	row := q.db.QueryRow(ctx, getRequestById, id)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.UserID,
		&i.EndpointID,
		&i.Plan,
		&i.Path,
		&i.ResponseID,
		&i.Content,
		&i.Method,
		&i.SourceIp,
		&i.ContentSize,
		&i.ResponseCode,
		&i.Headers,
		&i.QueryParams,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.IsDeleted,
	)
	return i, err
}

const getRequestByUUID = `-- name: GetRequestByUUID :one
SELECT
    id, uuid, user_id, endpoint_id, plan, path, response_id, content, method, source_ip, content_size, response_code, headers, query_params, created_at, expires_at, is_deleted
FROM
    request
WHERE
    UUID = $1
    AND is_deleted = FALSE
    AND expires_at > NOW()
LIMIT
    1
`

func (q *Queries) GetRequestByUUID(ctx context.Context, uuid string) (Request, error) {
	row := q.db.QueryRow(ctx, getRequestByUUID, uuid)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.UserID,
		&i.EndpointID,
		&i.Plan,
		&i.Path,
		&i.ResponseID,
		&i.Content,
		&i.Method,
		&i.SourceIp,
		&i.ContentSize,
		&i.ResponseCode,
		&i.Headers,
		&i.QueryParams,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.IsDeleted,
	)
	return i, err
}
